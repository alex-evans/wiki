# Structure and Interpretation of Computer Programs
![](https://images-na.ssl-images-amazon.com/images/I/41RJ4IO1HRL._SX343_BO1,204,203,200_.jpg)

## Status
**Reading**

## Recap


## Notes
- **07/15/20 Night's Reflection:** Start of the book and I like the feel of the book but it's hard not to look over the fact that it will be a beast of a book to get through. So we will see. At least it appears to be well written. I liked the tying of writing programs as writing sorcery. It's a good mental image while coding, makes it fun and I think that's the opening point that this should be fun but we should keep getting stronger with what we make and become. The using of Lisp hit me as surprising but I have to remind myself this is an older book and also that it's good to pickup new languages and see what they are like. My tired brain may not be able to absorb much these days but at least I'll get a feel of this stuff.

    *For all its power, the computer is a harsh taskmaster.*

    *hardware always operates at a level more primitive than that at which we care to program*

    *Even though some programs resist precise specifications, it is the responsibility of the programmer to estimate, and always to attempt to improve, their performance*

        Not sure if I agree with this one. I know we want to focus on performance and that was probably more of a deal back when this is written but I believe readability is the focus to always attempt to improve on programs without hurting performance or quality.

    *We toast the Lisp programmer who pens his thoughts within nests of parentheses.*

    *Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as a soap bubble? - Alan J. Perlis*

    *Underlying our approach to this subject is our conviction that "computer science" is not a science and that its significance has little to do with computers. The computer revolution is a revolution in the way we think and in the way we express what we think.*

    **Chapter 1**
    *Thus, like the sorcerer's apprentice, novice programmers must learn to understand and to anticipate the consequences of their conjuring.*


- **07/16/20 Night's Reflection:** This book is going to be a beast. I'm enjoying the idea of th knowledge pulled from a book like this and I like the challenge but it's going to take many nights. Tonight gave me an introduction into Lisp / Scheme. I had heard of both before but never really seen it. At first (like most languages) it looks strange, but it's starting to make sense and I like the building blocks nature of it. I could see how once you have all the blocks built into each other you could create some really powerful things that would be easy to read. It is kind of a look into functional programming a bit in my eyes as it's just a bunch of small (functions) that are pieced together to build powerful procedures. This book is going to have less quotes written down as a lot of it is in context to the teaching it is doing at that time.

    *Elements of Programming... primitive expressions, means of comination, and means of abstraction*

    *interpreter runs in a read-eval-print loop.*


- **07/20/20 Night's Reflection:** Worked through the exercises. Mainly took time figuring out how to run Scheme files and get results. Finally got there. After that it was fun writing up some of the stuff. The terminiology is stuff I'll struggle with but I need to just keep having fun with it.


- **07/21/20 Night's Reflection:** Worked through some of the exercises but realizing that I'm going to be skipping the majority of the exercises. I want to see the answers and I know that if I spent the time on those exercises I would understand thing deeper but I'm just not going to get through this book inching along diving deep into the acadmeic side of some of this stuff. I need to remember that my goal is my craft and doing that this needs to be interesting and successful. Knowing myself this means I'm going to pick what I can from the readings, which I am finding a lot of good stuff out of it and try to spend a little of time on the exercises but really keep things going. This reading tonight got into some stuff that is repeat for me as it talked about how to break up programs into small single focused programs so that they can be bundled together but keep things simple. Outside of that got into the shape of procedures with recursion which is a weak point of mine so always good to get a refresher. It was interesting that the "better" solution wasn't always what I would have picked and they even point out that some times readability is important.

- **07/24/20 Night's Reflection:** chewing my way through this book. Starting to worry a bit that not doing the exercises are really going to make this a waste of time but I really don't see myself spending 3 years working my way through this book. I want to pull the big ticket items from the book and see if I can pick up what is going on but I don't see myself slogging through every detail. Tonight only got a few pages through it and it was starting to not sit in to well so I stepped away from it. Will dive deeper with a fresh brain.

- **07/26/20 CHAPTER 1 Ending:** Some interesting mathematical formulas dug into in the chapter. I spent some time thinking through the concepts but I didn't burn my brain out trying to fully understand each detail. This book is going to give me a sense of what a Computer Science program teaches and general knowledge of the topics but I've stop expecting that I'll solve each exercise and know these concepts down to the itty gritty details. Reading it outside of a course without a class instruction will probably be the reason for this but I feel this is ok. In general I would guess most CS majors a few years removed from taking the course wont remember those itty gritty details (unless they are full on acadmic side of the world) and instead will remember the general details that I'm hoping to capture with this book. I'm enjoying reading about the concepts and will trek on. It is interesting relearning some of the things I remember learning with my math major from a decade ago and so it is fun to approach these from a different angle and think about them with a computer programming idea and background. I also find it interesting pulling things from this book that are helpful for the real world of development. Really what this chapter is focused on from what I could tell is how we can abstract procedures and continue to work on them to eventually get a readable easy to understand solution. I think it will continue down that path. This is stuff I have picked up as a developer over the years too and I think a student tackling these concepts wouldn't fully grasp that. This might be the failure of the academic world, where I get the approach and ideas behind it but unless you fully understand that as a student you're just going to be trying to keep your head above water understanding the gritty details. Wonder if a real world CS path would be an interesting major to take on.

- **07/26/20 Night's Reflection:** Getting into "data" abstraction now. Interesting stuff as all of it has been. As we've seen though, it's all about making complex things a grouping of simple things. If you can break things down into their own individual pieces it make understanding and stability while handling changes all the easier. This is why down the line here I'd like to look deeper into Functional coding and tackle a language that makes that a easier thing to use.

- **07/27/20 Night's Reflection:** Some more interesting stuff around the whole side of how Lisp works. Feels more like a language describer but it is talking about what goes into a language. I'm getting some of the terms that are used throughout programming so hopefully picking up some stuff. Some interesting stuff around how Lisp handles lists and how to manipulate things there.
